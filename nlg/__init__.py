"""
Natural language generator.

Here are the ContentPlanMessage message types, listed in the following format:

'message_name'
    'attribute' : Type of value
    'attribute2' : Type of value (Optional)

For example, this would be instantiated as

>>> message = ContentPlanMessage('message_name')
>>> message['attribute'] = 1
>>> message['attribute2'] = "Hello World!"
>>> message.msg_type
'message_name'

------------------------------------------------------------------------------

'echo'
    'message' : A string to display verbatim to the user.

'show_recipe'
    'recipe' : Recipe object

'summarize_query'
    'query' : A dictionary specifying a recipe query sent to the database.
              See Database.get_recipes() for the possible keys and values.

'clarify'
    'clarify_cat' : The category of the object being clarified.
    'clarify_list' : A list of objects that clarify is asking the user to
                     choose from.

'acknowledge'
'affirm'
'decline'
'unknown'

"""
import random
import logging
from simplenlg import NPPhraseSpec, PPPhraseSpec, SPhraseSpec, Realiser, \
    gateway, InterrogativeType, TextSpec, Tense, Form


HORIZONTAL_LINE = '-' * 70

REALISER = Realiser()


class ContentPlanMessage(dict):
    """
    Representation of content to express to user, generated by the DM
    for use by the NLG.  You can pass keyword arguments that function
    identically to dict's constructor:

    >>> plan = ContentPlanMessage('echo', message="Hello World")
    >>> plan['message']
    'Hello World'
    """

    def __init__(self, msg_type, **kwargs):
        dict.__init__(self, **kwargs)
        self.msg_type = msg_type

    def __str__(self):
        return "ContentPlanMessage('%s'): %s'" % \
            (self.msg_type, dict.__str__(self))


class NaturalLanguageGenerator(object):

    def __init__(self, logger):
        """
        Creates a new Natural Lanaguage Generator.

        conf_responses: a list of preconfigured templates to express
                        acknowledgement of input or action
        aff_responses: a list of preconfigured templates to express
                       affirmation or to say 'yes'
        neg_responses: a list of preconfigured templates to express
                       decline of request or action or to say 'no'
        """
        self.search_verbs = ['look for',
                             'search for',
                             'bring you',
                             'seek',
                             'find']

        self.conf_responses = ['You got it',
                              'As you wish',
                              'You don\'t have to ask me twice',
                              'Of course',
                              'Okay',
                              'acknowledged']

        self.aff_responses = ['Yes',
                              'Yeah',
                              'Very much so',
                              'Affirmative']

        self.neg_responses = ['No',
                              'Nah',
                              'Negative',
                              'I\'m afraid not']

        self.words = {'name': 'Jeraziah',
                      'subject': 'you',
                      'verb': 'prefer',
                      'object': 'recipes',
                      'preposition': 'that contains',
                      'objmodifiers': ['Thai'],
                      'prepmodifiers': ['potatoes', 'celery', 'carrots'],
                      'adverbs': ['confidently'],
                      'lastinput': 'Sing me a song.',
                      'clarify_cat': 'meat',
                      'clarify_list': ['chicken', 'beef', 'pork']}

        self.query = {'include_ingredients': ['chicken', 'pineapple', 'pepper'],
                      'exclude_ingredients': ['dishwashing soap', 'salt'],
                      'include_cuisines': ['Mexican', 'Chinese', 'Thai']}

        self.tone = 'normal'

        self.cruel_words = {
            'names': ['maggot', 'little snot', 'jerk', 'weakling'],
            'adjectives': ['incompetent', 'worthless', 'useless']
        }
        self.affectionate_words = {
            'names': ['honey', 'love', 'sweetie'],
            'adjectives': ['my']
        }
        self.normal_words = {
            'names': ['bro', 'brah', 'broseph', 'friend', 'buddy', 'comrade',
                      'amigo'],
            'adjectives': ['awesome', 'fantastic', 'cool']
        }

        self.log = logger
        self.log.info('NLG creation successful')

    def generate_response(self, content_plan_or_plans):
        """
        Given a list of content plans representing the content to be
        expressed, return a generated utterance.  As a convience, you may pass
        a single content_plan instead of a list of content plans.

        >>> nlg = NaturalLanguageGenerator(logging.getLogger())
        >>> message1 = ContentPlanMessage('echo')
        >>> message2 = ContentPlanMessage('echo')
        >>> message1['message'] = "Hello"
        >>> message2['message'] = "World"
        >>> print nlg.generate_response(message1)
        Hello
        >>> print nlg.generate_response([message1, message2])
        Hello
        World
        """
        if isinstance(content_plan_or_plans, ContentPlanMessage):
            return self.handle_content_plan_message(content_plan_or_plans)
        response = []
        for plan in content_plan_or_plans:
            response.append(self.handle_content_plan_message(plan))
        return '\n'.join(response)

    def handle_content_plan_message(self, content_plan):
        """
        Generate an utterance from a single ContentPlanMessage.
        """
        if content_plan.msg_type == "echo":
            return content_plan['message']
        elif content_plan.msg_type == "show_recipe":
            return '\n'.join([
                self.acknowledge(),
                self.generate_recipe(content_plan['recipe'])
            ])
        elif content_plan.msg_type == "summarize_query":
            return self.summarize_query(content_plan['query'])
        elif content_plan.msg_type == "clarify":
            return self.clarify(content_plan)
        elif content_plan.msg_type == "acknowledge":
            return self.acknowledge()
        elif content_plan.msg_type == "affirm":
            return self.affirm()
        elif content_plan.msg_type == "decline":
            return self.decline()
        elif content_plan.msg_type == "unknown":
            return self.unknown()
        else:
            self.log.error("Don't know how to handle msg_type '%s'" %
                content_plan.msg_type)
            return ""

    def generate_recipe(self, recipe):
        """
        Receives a Recipe object and displays its contents to the user.
        """
        output = []

        output.append('Here is the recipe you requested: \n')
        output.append(HORIZONTAL_LINE)
        output.append(recipe.title + ' by ' + recipe.author)
        output.append(recipe.description)
        output.append('\n')
        cuisines_str = 'Cuisines: ' + \
            ', '.join(c.name for c in recipe.cuisines)
        output.append(cuisines_str)
        output.append("Servings: %s" % recipe.servings)
        if recipe.prep_time:
            output.append("Prep Time: %i minutes" % (recipe.prep_time))
        if recipe.cook_time:
            output.append("Cook Time: %i minutes" % (recipe.cook_time))
        if recipe.total_time:
            output.append("Total Time: %i minutes" % (recipe.total_time))
        output.append('\n')
        output.append(recipe.ingredients_text)
        output.append('\n')
        output.append(recipe.steps_text)
        output.append(HORIZONTAL_LINE)

        return '\n'.join(output)

    def generate(self, utter_type, keywords):
        """
        Input: a type of inquiry to create and a dictionary of keywords.
        Types of inquiries include 'what', 'who', 'where', 'why', 'how',
        and 'yes/no' questions. Alternatively, 'none' can be specified to
        generate a declarative statement.

        The dictionary is essentially divided into three core parts: the
        subject, the verb, and the object. Modifiers can be specified to these
        parts (adverbs, adjectives, etc). Additionally, an optional
        prepositional phrase can be specified.

        Example:

        >>> nlg = NaturalLanguageGenerator(logging.getLogger())
        >>> words = {'subject': 'you',
        ...         'verb': 'prefer',
        ...         'object': 'recipes',
        ...         'preposition': 'that contains',
        ...         'objmodifiers': ['Thai'],
        ...         'prepmodifiers': ['potatoes', 'celery', 'carrots'],
        ...         'adverbs': ['confidently'],
        ... }
        >>> nlg.generate('yes_no', words)
        u'Do you confidently prefer Thai recipes that contains potatoes, celery and carrots?'
        >>> nlg.generate('how', words)
        u'How do you confidently prefer Thai recipes that contains potatoes, celery and carrots?'
        """
        if utter_type.lower() == 'greet':
            if 'name' in keywords:
                self.normal_words['names'].append(keywords['name'])
            return 'Hello, %s!' % (self.tone_str('names'))
        utterance = SPhraseSpec()
        subject = NPPhraseSpec(keywords['subject'])
        target = NPPhraseSpec(keywords['object'])
        preposition = PPPhraseSpec()

        if 'preposition' in keywords:
            preposition.setPreposition(keywords['preposition'])

        if 'prepmodifiers' in keywords:
            for modifier in keywords['prepmodifiers']:
                preposition.addComplement(modifier)

        if 'submodifiers' in keywords:
            for modifier in keywords['submodifiers']:
                subject.addModifier(modifier)

        if 'objmodifiers' in keywords:
            for modifier in keywords['objmodifiers']:
                target.addModifier(modifier)

        if utter_type.lower() == 'yes_no':
            utterance.setInterrogative(InterrogativeType.YES_NO)
        elif utter_type.lower() == 'how':
            utterance.setInterrogative(InterrogativeType.HOW)
        elif utter_type.lower() == 'what':
            utterance.setInterrogative(InterrogativeType.WHAT)
        elif utter_type.lower() == 'where':
            utterance.setInterrogative(InterrogativeType.WHERE)
        elif utter_type.lower() == 'who':
            utterance.setInterrogative(InterrogativeType.WHO)
        elif utter_type.lower() == 'why':
            utterance.setInterrogative(InterrogativeType.WHY)

        target.addModifier(preposition)
        utterance.setSubject(keywords['subject'])
        utterance.setVerb(keywords['verb'])
        if 'adverbs' in keywords:
            for modifier in keywords['adverbs']:
                utterance.addModifier(modifier)
        utterance.addComplement(target)

        output = REALISER.realiseDocument(utterance).strip()
        return output

    def acknowledge(self):
        """
        Returns an utterance of acknowledgement at random.
        A template is picked randomly from preconfigured choices.
        Then, the choice of adding the user's name is randomly determined.
        Finally, either a period or exclamation mark is used to end the
        sentence.
        """

        acknowledgement = random.choice(self.conf_responses)
        acknowledgement += random.choice([', ' + random.choice([self.tone_str('adjectives') + ' ', '']) + self.tone_str('names'), ''])
        return acknowledgement + random.choice(['.', '!'])

    def affirm(self):
        """
        Returns an utterance of affirmation at random.
        A template is picked randomly from preconfigured choices.
        Then, the choice of adding the user's name is randomly determined.
        Finally, either a period or exclamation mark is used to end the
        sentence.
        """

        affirmation = random.choice(self.aff_responses)
        affirmation += random.choice([', ' + random.choice([self.tone_str('adjectives') + ' ', '']) + self.tone_str('names'), ''])
        return affirmation + random.choice(['.', '!'])

    def decline(self):
        """
        Returns an utterance of denial or decline of action.
        A template is picked randomly from preconfigured choices.
        Then, the choice of adding the user's name is randomly determined.
        Finally, either a period or exclamation mark is used to end the
        sentence.
        """

        decline = random.choice(self.neg_responses)
        decline += random.choice([', ' + random.choice([self.tone_str('adjectives') + ' ', '']) + self.tone_str('names'), ''])
        return decline + random.choice(['.', '!'])

    def unknown(self):
        """
        Returns an utterance that tells the user the last input was not
        understood.
        """

        output = SPhraseSpec()
        output.setSubject('I')
        output.setComplement('you')
        output.setTense(Tense.PAST)

        choice = random.randint(1, 3)
        if choice == 1:
            output.setVerb('understand')
            output.setComplement('what you')
            output.setNegated(gateway.jvm.java.lang.Boolean.TRUE)
            output.setPostmodifier('just said')
        elif choice == 2:
            output.setInterrogative(InterrogativeType.WHAT)
            output.setVerb('do')
            output.setPostmodifier('say')
        elif choice == 3:
            output.setTense(Tense.PRESENT)
            output.setSubject('please rephrase')
            output.setComplement('what you')
            output.setPostmodifier('just said')

        return REALISER.realiseDocument(output).strip()

    def clarify(self, keywords):
        """
        Asks the user to specify a certain criteria if it is too broad.
        """

        # if the necessary fields do not exist, then throw an exception
        if 'clarify_cat' not in keywords or 'clarify_list' not in keywords:
            raise NLGException('Not enough information in keywords')

        # the first clause gets the user's attention
        stat1 = SPhraseSpec('Hey ' + random.choice([random.choice([self.tone_str('adjectives') + ' ', '']) + self.tone_str('names'), '']), '')
        # the second clause acknowledges that a specification was given
        stat2 = SPhraseSpec('I', 'know', 'you wanted a type of %s' % (keywords['clarify_cat']))
        # the third clause asks the user to provide a more narrow scope
        stat3 = SPhraseSpec()
        stat3.setCuePhrase('but please specify if')
        stat3.setVerb('meant')
        stat3.setSubject('you')
        uniques = ''
        for unique in keywords['clarify_list']:
            if unique == keywords['clarify_list'][0]:
                uniques += unique
            elif unique == keywords['clarify_list'][-1]:
                uniques += ', or ' + unique
            else:
                uniques += ', ' + unique
        stat3.setPostmodifier(uniques)

        # create the final utterance out of all the parts
        clarification = TextSpec()
        clarification.addSpec(stat1)
        clarification.addSpec(stat2)
        clarification.addSpec(stat3)
        clarification.setListConjunct(',')

        return REALISER.realiseDocument(clarification).strip()

    def summarize_query(self, query):
        """
        Returns an utterance that rewords the inputted query as a form
        of acknowledgement to the user.
        """

        # if no criteria is provided, let the user know that every dish
        # will be searched
        if query == {}:
            return 'I will just look for every recipe we have.'

        summary = SPhraseSpec()
        summary.setSubject('I')
        summary.setVerb(random.choice(self.search_verbs))
        summary.setProgressive(gateway.jvm.java.lang.Boolean.TRUE)

        # add specified cuisines included, if they exist
        if 'include_cuisines' in query:
            for cuisine in query['include_cuisines']:
                if cuisine == query['include_cuisines'][-1]:
                    summary.addComplement(cuisine + ' dishes')
                else:
                    summary.addComplement(cuisine)
        else:
            summary.addComplement('recipes')

        # create phrase to include ingredients
        if 'include_ingredients' in query:
            ing_inc = PPPhraseSpec()
            ing_inc.setPreposition('that contain')
            for ingredient in query['include_ingredients']:
                ing_inc.addComplement(ingredient)
            summary.addModifier(ing_inc)

        # create phrase to exclude ingredients
        if 'exclude_ingredients' in query:
            ing_exc = PPPhraseSpec()
            ing_exc.setPreposition('but do not contain')
            for ingredient in query['exclude_ingredients']:
                ing_exc.addComplement(ingredient)
            summary.addModifier(ing_exc)

        # create phrase to include recipe times and number of steps
        # and/or ingredients

        steps = SPhraseSpec()
        if 'prep_time' in query or 'cook_time' in query or 'total_time' in query or 'num_steps' in query or 'num_ingredients' in query:
            steps.setSubject('I')
            steps.setVerb(random.choice(self.search_verbs))
            steps.setProgressive(gateway.jvm.java.lang.Boolean.TRUE)
            steps.addPremodifier('also')

            steps_list = []
            if 'prep_time' in query and query['prep_time'] != None:
                steps_list.append('%i minutes to prepare' % query['prep_time'])
            if 'cook_time' in query and query['cook_time'] != None:
                steps_list.append('%i minutes to cook' % (query['cook_time']))
            if 'total_time' in query and query['total_time'] != None:
                steps_list.append('%i total minutes to make' %
                                  (query['total_time']))
            if 'num_steps' in query and query['num_steps'] != None:
                steps_list.append('%i steps to complete' % (query['num_steps']))
            if 'num_ingredients' in query and query['num_ingredients'] != None:
                steps_list.append('%i ingredients' % (query['num_ingredients']))
            for step in steps_list:
                if step == steps_list[0]:
                    steps.addComplement('recipes that require ' + step)
                else:
                    steps.addComplement(step)

        # tie everything together into one utterance
        final = TextSpec()
        final.addSpec(summary)
        final.addSpec(steps)
        final.setListConjunct('.')

        return REALISER.realiseDocument(final).strip()

    def change_tone(self, tone):
        """
        Changes the tone of the utterances created by the NLG.
        If the inputted tone is not recognized by the NLG, then it will
        default to normal.
        """

        self.tone = tone

    def tone_str(self, key):
        """
        Helper function used to extract a random word or phrase
        from the current tone's dictionary. If the given key does not exist,
        an empty string is returned.
        """

        if self.tone == 'cruel':
            if key in self.cruel_words:
                return random.choice(self.cruel_words[key])
        if self.tone == 'affectionate':
            if key in self.affectionate_words:
                return random.choice(self.affectionate_words[key])
        if self.tone == 'normal':
            if key in self.normal_words:
                return random.choice(self.normal_words[key])
        return ''


class NLGException(Exception):
    """
    Base class for exceptions related to the NLG
    """
    pass


def demo():
    """
    A demo that prints generates every utterance type (except show_recipe).

    >>> demo_output = demo()  # Make sure that the demo doesn't crash.
    """
    messages = [
        ContentPlanMessage('echo', message="Hello World"),
        ContentPlanMessage('summarize_query',
            query={'include_ingredients': ['egg']}),
        ContentPlanMessage('clarify', clarify_cat='ingredient',
            clarify_list=['chicken', 'beef', 'pork']),
        ContentPlanMessage('acknowledge'),
        ContentPlanMessage('affirm'),
        ContentPlanMessage('decline'),
        ContentPlanMessage('unknown')
    ]
    nlg = NaturalLanguageGenerator(logging.getLogger())
    return nlg.generate_response(messages)


if __name__ == '__main__':
    print demo()
